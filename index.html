<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Copy Call</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: monospace;
        background: #000;
        color: #fff;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        overscroll-behavior: none;
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
          env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      .container {
        min-height: 100vh;
        max-width: 414px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        border-left: 1px solid #333;
        border-right: 1px solid #333;
      }

      .header {
        padding: 15px;
        background: rgba(0, 0, 0, 0.8);
        text-align: center;
        border-bottom: 1px solid #333;
      }

      .header h1 {
        font-size: 20px;
        font-weight: 600;
      }

      .status {
        padding: 12px 15px;
        font-weight: 500;
        font-size: 14px;
        text-align: center;
      }

      .status.waiting {
        background: #ff9500;
      }

      .status.connected {
        background: #34c759;
      }

      .status.error {
        background: #ff3b30;
      }

      .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 15px;
        gap: 20px;
      }

      .link-section,
      .code-section {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 15px;
      }

      .link-input,
      .code-textarea {
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #333;
        border-radius: 8px;
        color: #fff;
        font-family: monospace;
        font-size: 12px;
        padding: 12px;
        margin-bottom: 15px;
        resize: none;
      }

      .code-textarea {
        min-height: 120px;
        font-size: 11px;
      }

      .btn {
        background: #007aff;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 15px 25px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
        margin-bottom: 10px;
        transition: background 0.2s;
        -webkit-appearance: none;
        appearance: none;
        touch-action: manipulation;
      }

      .btn:active {
        background: #005bb5;
        transform: scale(0.98);
      }

      .btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      .btn.success {
        background: #34c759;
      }

      .btn.success:active {
        background: #2fb44a;
      }

      .code-display {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 10px;
        font-family: monospace;
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
        word-break: break-all;
        line-height: 1.3;
        max-height: 60px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        border: 1px solid #333;
      }

      .video-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 300px;
      }

      .video-grid {
        display: grid;
        gap: 10px;
        flex: 1;
      }

      .video-grid.portrait {
        grid-template-rows: 1fr 1fr;
      }

      .video-grid.landscape {
        grid-template-columns: 1fr 1fr;
      }

      .video-box {
        background: #000;
        border-radius: 12px;
        position: relative;
        overflow: hidden;
        min-height: 150px;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
      }

      .video-label {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 6px 12px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: 500;
      }

      .video-controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }

      .control-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        cursor: pointer;
        transition: all 0.2s;
        -webkit-appearance: none;
        appearance: none;
        touch-action: manipulation;
      }

      .control-btn.mic {
        background: rgba(0, 0, 0, 0.7);
        color: white;
      }

      .control-btn.mic.muted {
        background: #ff3b30;
        color: white;
      }

      .control-btn.camera {
        background: rgba(0, 0, 0, 0.7);
        color: white;
      }

      .control-btn.camera.disabled {
        background: #ff3b30;
        color: white;
      }

      .control-btn:active {
        transform: scale(0.9);
      }

      .video-box.local {
        position: relative;
      }

      .video-box.muted video {
        opacity: 0.7;
      }

      .video-box.camera-off video {
        opacity: 0.3;
      }

      .video-box.camera-off::after {
        content: 'üì∑';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 40px;
        opacity: 0.8;
      }

      .placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        font-style: italic;
        text-align: center;
        padding: 20px;
      }

      .hidden {
        display: none !important;
      }

      .debug {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 10px;
        font-family: monospace;
        font-size: 10px;
        max-height: 100px;
        overflow-y: auto;
        margin-top: auto;
        -webkit-overflow-scrolling: touch;
      }

      .flex-col {
        display: flex;
        flex-direction: column;
      }

      .gap-20 {
        gap: 20px;
      }

      /* Landscape orientation adjustments */
      @media (orientation: landscape) and (max-height: 600px) {
        .header h1 {
          font-size: 16px;
        }

        .content {
          padding: 10px;
          gap: 15px;
        }

        .video-container {
          min-height: 200px;
        }

        .video-box {
          min-height: 120px;
        }
      }

      /* Remove desktop adaptations - keep mobile-only styling */
      @media (min-width: 415px) {
        .container {
          box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }
      }

      /* Prevent zoom on input focus */
      @media (max-width: 767px) {
        .link-input,
        .code-textarea {
          font-size: 16px;
        }
      }

      /* iOS specific styles */
      @supports (-webkit-touch-callout: none) {
        .btn {
          -webkit-tap-highlight-color: transparent;
        }
      }

      /* Floating Action Button */
      .fab {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: #005bb5;
        color: white;
        border: none;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: all 0.3s;
        z-index: 1000;
        -webkit-appearance: none;
        appearance: none;
        touch-action: manipulation;
      }

      .fab:hover {
        transform: scale(1.1);
      }

      .fab:active {
        transform: scale(0.9);
      }

      @media (max-width: 414px) {
        .fab {
          right: 15px;
          bottom: 15px;
        }
      }
    </style>
  </head>

  <body>
    <div class="container">
      <!-- <div class="header">
        <h1>Copy Call</h1>
      </div> -->

      <div id="status" class="status waiting">Initializing...</div>

      <!-- HTTPS Warning -->
      <div id="https-warning" class="status error hidden">
        ‚ö†Ô∏è HTTPS Required - Camera access may be blocked over HTTP
      </div>

      <div class="content">
        <!-- Initiator Mode: Generate Offer -->
        <div id="initiator-generate" class="hidden gap-20 flex-col">
          <div class="link-section">
            <input type="text" id="offer-link" class="link-input" readonly />
            <button id="copy-offer" class="btn">Copy Link</button>
          </div>

          <div class="code-section">
            <textarea
              id="answer-code-input"
              class="code-textarea"
              placeholder="Paste response code..."
            ></textarea>
            <button id="connect-btn" class="btn success">Connect</button>
          </div>
        </div>

        <!-- Responder Mode: Generate Code -->
        <div id="responder-generate" class="hidden">
          <div class="code-section">
            <div class="code-display" id="answer-code-display"></div>
            <button id="copy-code" class="btn">Copy Code</button>
          </div>

          <div class="video-container">
            <div class="video-grid portrait" id="responder-video-grid">
              <div class="video-box local" id="responder-local-box">
                <video
                  id="responder-local-video"
                  autoplay
                  muted
                  playsinline
                ></video>
                <div class="video-label">You</div>
                <div class="video-controls">
                  <button
                    class="control-btn mic"
                    id="responder-mic-btn"
                    title="Toggle microphone"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      class="lucide lucide-mic-icon lucide-mic"
                    >
                      <path d="M12 19v3" />
                      <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                      <rect x="9" y="2" width="6" height="13" rx="3" />
                    </svg>
                  </button>
                  <button
                    class="control-btn camera"
                    id="responder-camera-btn"
                    title="Toggle camera"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      class="lucide lucide-video-icon lucide-video"
                    >
                      <path
                        d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"
                      />
                      <rect x="2" y="6" width="14" height="12" rx="2" />
                    </svg>
                  </button>
                </div>
              </div>
              <div class="video-box">
                <div class="placeholder" id="responder-remote-placeholder">
                  Waiting for connection...
                </div>
                <video
                  id="responder-remote-video"
                  autoplay
                  playsinline
                  class="hidden"
                ></video>
                <div class="video-label">Remote</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Connected Mode -->
        <div id="connected-mode" class="hidden">
          <div class="video-container">
            <div class="video-grid" id="connected-video-grid">
              <div class="video-box local" id="connected-local-box">
                <video id="local-video" autoplay muted playsinline></video>
                <div class="video-label">You</div>
                <div class="video-controls">
                  <button
                    class="control-btn mic"
                    id="connected-mic-btn"
                    title="Toggle microphone"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      class="lucide lucide-mic-icon lucide-mic"
                    >
                      <path d="M12 19v3" />
                      <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                      <rect x="9" y="2" width="6" height="13" rx="3" />
                    </svg>
                  </button>
                  <button
                    class="control-btn camera"
                    id="connected-camera-btn"
                    title="Toggle camera"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      class="lucide lucide-video-icon lucide-video"
                    >
                      <path
                        d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"
                      />
                      <rect x="2" y="6" width="14" height="12" rx="2" />
                    </svg>
                  </button>
                </div>
              </div>
              <div class="video-box">
                <video id="remote-video" autoplay playsinline></video>
                <div class="video-label">Remote</div>
              </div>
            </div>
          </div>
        </div>

        <div id="debug" class="debug hidden"></div>
      </div>

      <!-- Floating Action Button -->
      <button id="reload-fab" class="fab" title="Reload page">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="lucide lucide-refresh-cw-icon lucide-refresh-cw"
        >
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
          <path d="M21 3v5h-5" />
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
          <path d="M8 16H3v5" />
        </svg>
      </button>
    </div>

    <script>
      class MobileWebRTC {
        constructor() {
          this.pc = null;
          this.localStream = null;
          this.mode = null;
          this.currentCode = null;
          this.isLandscape = window.innerWidth > window.innerHeight;
          this.audioTrack = null;
          this.videoTrack = null;
          this.isMicEnabled = true;
          this.isCameraEnabled = true;

          this.init();
          this.setupOrientationHandling();
        }

        async init() {
          this.log('Initializing mobile WebRTC...');
          this.logSystemInfo();

          // Check browser compatibility and permissions
          const compatibilityResult = await this.checkCompatibility();
          if (!compatibilityResult.compatible) {
            this.updateStatus('Browser not supported', 'error');
            this.showAlert(compatibilityResult.message);
            return;
          }

          // Show HTTPS warning if needed
          if (!this.isHTTPS()) {
            this.log(
              'Warning: Running over HTTP - camera access may be restricted'
            );
            this.showHTTPSWarning();
          }

          const urlData = await this.getUrlData();

          if (urlData && urlData.type === 'offer') {
            this.mode = 'responder';
            await this.handleOffer(urlData);
          } else {
            this.mode = 'initiator';
            await this.createOffer();
          }

          this.setupEventListeners();
        }

        setupOrientationHandling() {
          const updateLayout = () => {
            this.isLandscape = window.innerWidth > window.innerHeight;
            const videoGrids = document.querySelectorAll('.video-grid');

            videoGrids.forEach((grid) => {
              grid.className = `video-grid ${
                this.isLandscape ? 'landscape' : 'portrait'
              }`;
            });

            this.log(
              `Orientation: ${this.isLandscape ? 'landscape' : 'portrait'}`
            );
          };

          window.addEventListener('orientationchange', () => {
            setTimeout(updateLayout, 100);
          });

          window.addEventListener('resize', updateLayout);
          updateLayout();
        }

        setupEventListeners() {
          document
            .getElementById('copy-offer')
            .addEventListener('click', () => {
              this.copyToClipboard(
                document.getElementById('offer-link').value,
                'copy-offer'
              );
            });

          document.getElementById('copy-code').addEventListener('click', () => {
            this.copyToClipboard(this.currentCode, 'copy-code');
          });

          document
            .getElementById('connect-btn')
            .addEventListener('click', () => {
              this.handleAnswerCode();
            });

          // Prevent zoom on iOS when focusing textarea
          document
            .getElementById('answer-code-input')
            .addEventListener('touchstart', (e) => {
              e.target.style.fontSize = '16px';
            });

          // Setup media control buttons
          this.setupMediaControls();

          // Setup FAB
          this.setupFAB();
        }

        setupMediaControls() {
          // Responder mode controls
          const responderMicBtn = document.getElementById('responder-mic-btn');
          const responderCameraBtn = document.getElementById(
            'responder-camera-btn'
          );

          // Connected mode controls
          const connectedMicBtn = document.getElementById('connected-mic-btn');
          const connectedCameraBtn = document.getElementById(
            'connected-camera-btn'
          );

          if (responderMicBtn) {
            responderMicBtn.addEventListener('click', () =>
              this.toggleMicrophone()
            );
          }
          if (responderCameraBtn) {
            responderCameraBtn.addEventListener('click', () =>
              this.toggleCamera()
            );
          }
          if (connectedMicBtn) {
            connectedMicBtn.addEventListener('click', () =>
              this.toggleMicrophone()
            );
          }
          if (connectedCameraBtn) {
            connectedCameraBtn.addEventListener('click', () =>
              this.toggleCamera()
            );
          }
        }

        toggleMicrophone() {
          if (!this.audioTrack) return;

          this.isMicEnabled = !this.isMicEnabled;
          this.audioTrack.enabled = this.isMicEnabled;

          const micBtns = document.querySelectorAll('.control-btn.mic');
          const localBoxes = document.querySelectorAll('.video-box.local');

          micBtns.forEach((btn) => {
            if (this.isMicEnabled) {
              btn.classList.remove('muted');
              btn.innerHTML =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic-icon lucide-mic"><path d="M12 19v3"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><rect x="9" y="2" width="6" height="13" rx="3"/></svg>';
            } else {
              btn.classList.add('muted');
              btn.innerHTML =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic-off-icon lucide-mic-off"><path d="M12 19v3"/><path d="M15 9.34V5a3 3 0 0 0-5.68-1.33"/><path d="M16.95 16.95A7 7 0 0 1 5 12v-2"/><path d="M18.89 13.23A7 7 0 0 0 19 12v-2"/><path d="m2 2 20 20"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12"/></svg>';
            }
          });

          localBoxes.forEach((box) => {
            if (this.isMicEnabled) {
              box.classList.remove('muted');
            } else {
              box.classList.add('muted');
            }
          });

          this.log(`Microphone ${this.isMicEnabled ? 'enabled' : 'disabled'}`);
        }

        toggleCamera() {
          if (!this.videoTrack) return;

          this.isCameraEnabled = !this.isCameraEnabled;
          this.videoTrack.enabled = this.isCameraEnabled;

          const cameraBtns = document.querySelectorAll('.control-btn.camera');
          const localBoxes = document.querySelectorAll('.video-box.local');

          cameraBtns.forEach((btn) => {
            if (this.isCameraEnabled) {
              btn.classList.remove('disabled');
              btn.innerHTML =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-video-icon lucide-video"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/><rect x="2" y="6" width="14" height="12" rx="2"/></svg>';
            } else {
              btn.classList.add('disabled');
              btn.innerHTML =
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-video-off-icon lucide-video-off"><path d="M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196"/><path d="M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2"/><path d="m2 2 20 20"/></svg>';
            }
          });

          localBoxes.forEach((box) => {
            if (this.isCameraEnabled) {
              box.classList.remove('camera-off');
            } else {
              box.classList.add('camera-off');
            }
          });

          this.log(`Camera ${this.isCameraEnabled ? 'enabled' : 'disabled'}`);
        }

        setupFAB() {
          const reloadFab = document.getElementById('reload-fab');
          if (reloadFab) {
            reloadFab.addEventListener('click', () => {
              window.location.reload();
            });
          }
        }

        showFAB() {
          const reloadFab = document.getElementById('reload-fab');
          if (reloadFab) {
            reloadFab.classList.remove('hidden');
          }
        }

        hideResponderInterface() {
          // Hide the code section but keep video
          const codeSection = document.querySelector(
            '#responder-generate .code-section'
          );
          if (codeSection) {
            codeSection.classList.add('hidden');
          }
          this.log('Responder interface hidden - showing only video');
        }

        setupPeerConnection() {
          this.pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ],
          });

          this.pc.oniceconnectionstatechange = () => {
            this.log(`ICE: ${this.pc.iceConnectionState}`);
          };

          this.pc.onconnectionstatechange = () => {
            this.log(`Connection: ${this.pc.connectionState}`);
            if (this.pc.connectionState === 'connected') {
              this.updateStatus('Connected! Video call active.', 'connected');
              this.showFAB();

              if (this.mode === 'initiator') {
                this.showConnectedMode();
              } else if (this.mode === 'responder') {
                // Hide responder interface, keep only video
                this.hideResponderInterface();
              }
            }
          };

          this.pc.ontrack = (event) => {
            this.log(`Remote track received: ${event.track.kind}`);
            const stream = event.streams[0];
            this.displayRemoteVideo(stream);
          };

          this.log('PeerConnection setup complete');
        }

        async createOffer() {
          this.log('Creating offer...');
          this.showMode('initiator-generate');
          this.updateStatus('Generating offer link...');

          this.setupPeerConnection();

          try {
            // Check if getUserMedia is available
            if (
              !navigator.mediaDevices ||
              !navigator.mediaDevices.getUserMedia
            ) {
              throw new Error('getUserMedia not supported');
            }

            // Get user media with mobile-optimized constraints
            this.localStream = await this.requestUserMedia();

            // Store track references and add tracks
            this.localStream.getTracks().forEach((track) => {
              this.pc.addTrack(track, this.localStream);
              this.log(`Added ${track.kind} track`);

              if (track.kind === 'audio') {
                this.audioTrack = track;
              } else if (track.kind === 'video') {
                this.videoTrack = track;
              }
            });

            // Create offer
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            // Wait for ICE
            await this.waitForIceGathering();

            // Generate offer link
            const linkData = {
              type: 'offer',
              offer: this.pc.localDescription,
            };

            const link = await this.generateLink(linkData);
            document.getElementById('offer-link').value = link;

            this.updateStatus('Share the link and wait for response code');
          } catch (error) {
            this.handleMediaError(error, 'creating offer');
          }
        }

        async handleOffer(urlData) {
          this.log('Handling incoming offer...');
          this.showMode('responder-generate');
          this.updateStatus('Processing offer...');

          this.setupPeerConnection();

          try {
            // Check if getUserMedia is available
            if (
              !navigator.mediaDevices ||
              !navigator.mediaDevices.getUserMedia
            ) {
              throw new Error('getUserMedia not supported');
            }

            // Get user media with mobile constraints
            this.localStream = await this.requestUserMedia();

            // Display local video
            document.getElementById('responder-local-video').srcObject =
              this.localStream;

            // Store track references and add tracks
            this.localStream.getTracks().forEach((track) => {
              this.pc.addTrack(track, this.localStream);
              this.log(`Added ${track.kind} track`);

              if (track.kind === 'audio') {
                this.audioTrack = track;
              } else if (track.kind === 'video') {
                this.videoTrack = track;
              }
            });

            // Process offer
            try {
              await this.pc.setRemoteDescription(urlData.offer);
              this.log('Remote offer set successfully');
            } catch (sdpError) {
              this.log(`SDP Error: ${sdpError.message}`);
              throw new Error(`Invalid offer data: ${sdpError.message}`);
            }

            // Create answer
            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);

            // Wait for ICE
            await this.waitForIceGathering();

            // Generate compressed answer
            const encodedAnswer = await this.compressData(
              this.pc.localDescription
            );
            this.currentCode = encodedAnswer;

            document.getElementById('answer-code-display').textContent =
              encodedAnswer;

            this.updateStatus('Code generated! Send it back to connect.');
          } catch (error) {
            this.handleMediaError(error, 'handling offer');
          }
        }

        async handleAnswerCode() {
          const codeInput = document.getElementById('answer-code-input');
          const encodedData = codeInput.value.trim();

          if (!encodedData) {
            this.showAlert('Please paste the response code');
            return;
          }

          this.log('Processing response code...');

          try {
            const answer = await this.decompressData(encodedData);
            try {
              await this.pc.setRemoteDescription(answer);
              this.log('Response code applied successfully');
              this.updateStatus('Connecting...');

              // Show video interface
              this.showConnectedMode();
            } catch (sdpError) {
              this.log(`SDP Error: ${sdpError.message}`);
              throw new Error(
                `Invalid response code format: ${sdpError.message}`
              );
            }
          } catch (error) {
            this.log(`Error with response code: ${error.message}`);
            this.showAlert(
              'Invalid response code. Please check and try again.'
            );
          }
        }

        displayRemoteVideo(stream) {
          this.log(`Displaying remote video for mode: ${this.mode}`);

          if (this.mode === 'responder') {
            const placeholder = document.getElementById(
              'responder-remote-placeholder'
            );
            const video = document.getElementById('responder-remote-video');

            if (placeholder) placeholder.classList.add('hidden');
            if (video) {
              video.srcObject = stream;
              video.classList.remove('hidden');
              this.log('Responder remote video set');
            }
          } else {
            const video = document.getElementById('remote-video');
            if (video) {
              video.srcObject = stream;
              this.log('Initiator remote video set');
            }
          }
        }

        showConnectedMode() {
          this.showMode('connected-mode');

          if (this.localStream) {
            document.getElementById('local-video').srcObject = this.localStream;
          }

          if (this.pc.connectionState !== 'connected') {
            this.updateStatus('Connecting...');
          }
        }

        waitForIceGathering() {
          return new Promise((resolve) => {
            if (this.pc.iceGatheringState === 'complete') {
              resolve();
              return;
            }

            const timeout = setTimeout(() => {
              this.log('ICE gathering timeout');
              resolve();
            }, 3000);

            this.pc.addEventListener('icegatheringstatechange', () => {
              if (this.pc.iceGatheringState === 'complete') {
                clearTimeout(timeout);
                resolve();
              }
            });
          });
        }

        async generateLink(data) {
          const encoded = await this.compressData(data);
          const baseUrl = window.location.href.split('#')[0];
          return `${baseUrl}#${encoded}`;
        }

        async getUrlData() {
          const hash = window.location.hash.substring(1);
          if (!hash) return null;

          try {
            return await this.decompressData(hash);
          } catch (error) {
            this.log(`Error parsing URL: ${error.message}`);
            return null;
          }
        }

        showMode(mode) {
          document
            .querySelectorAll(
              '#initiator-generate, #responder-generate, #connected-mode'
            )
            .forEach((el) => {
              el.classList.add('hidden');
            });
          document.getElementById(mode).classList.remove('hidden');
        }

        updateStatus(message, type = 'waiting') {
          const statusEl = document.getElementById('status');
          statusEl.textContent = message;
          statusEl.className = `status ${type}`;
        }

        showAlert(message) {
          // Use native alert for now, could be replaced with custom modal
          alert(message);
        }

        async copyToClipboard(text, buttonId) {
          try {
            await navigator.clipboard.writeText(text);
            const button = document.getElementById(buttonId);
            const originalText = button.textContent;
            button.textContent = '‚úì Copied!';
            button.disabled = true;

            setTimeout(() => {
              button.textContent = originalText;
              button.disabled = false;
            }, 2000);
          } catch (error) {
            this.log(`Copy failed: ${error.message}`);
            this.showAlert('Copy failed. Please copy manually.');
          }
        }

        async compressData(data) {
          try {
            // Optimize SDP before compression if it contains an offer/answer
            let optimizedData = data;
            if (data.offer && data.offer.sdp) {
              optimizedData = {
                ...data,
                offer: this.optimizeSdp(data.offer),
              };
            } else if (data.sdp) {
              // Handle direct session description
              optimizedData = this.optimizeSdp(data);
            }

            const jsonString = JSON.stringify(optimizedData);
            const stream = new CompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();

            const encoder = new TextEncoder();
            const chunks = [];

            writer.write(encoder.encode(jsonString));
            writer.close();

            let done = false;
            while (!done) {
              const { value, done: readerDone } = await reader.read();
              done = readerDone;
              if (value) {
                chunks.push(value);
              }
            }

            const compressed = new Uint8Array(
              chunks.reduce((acc, chunk) => acc + chunk.length, 0)
            );
            let offset = 0;
            for (const chunk of chunks) {
              compressed.set(chunk, offset);
              offset += chunk.length;
            }

            const base64 = btoa(String.fromCharCode(...compressed));
            this.log(
              `Compression: ${jsonString.length} ‚Üí ${
                base64.length
              } chars (${Math.round(
                (1 - base64.length / jsonString.length) * 100
              )}% reduction)`
            );
            return base64;
          } catch (error) {
            this.log(
              `Compression failed: ${error.message}, falling back to uncompressed`
            );
            return btoa(JSON.stringify(data));
          }
        }

        async decompressData(compressedBase64) {
          try {
            // First, try to parse as uncompressed base64 (simpler format)
            try {
              const uncompressedData = JSON.parse(atob(compressedBase64));
              this.log('Using uncompressed format');
              return uncompressedData;
            } catch (uncompressedError) {
              // If that fails, try compressed format
              this.log('Trying compressed format...');
            }

            const compressed = new Uint8Array(
              atob(compressedBase64)
                .split('')
                .map((c) => c.charCodeAt(0))
            );
            const stream = new DecompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();

            const chunks = [];

            writer.write(compressed);
            writer.close();

            let done = false;
            while (!done) {
              const { value, done: readerDone } = await reader.read();
              done = readerDone;
              if (value) {
                chunks.push(value);
              }
            }

            const decompressed = new Uint8Array(
              chunks.reduce((acc, chunk) => acc + chunk.length, 0)
            );
            let offset = 0;
            for (const chunk of chunks) {
              decompressed.set(chunk, offset);
              offset += chunk.length;
            }

            const decoder = new TextDecoder();
            const jsonString = decoder.decode(decompressed);
            const data = JSON.parse(jsonString);

            // Restore SDP optimization if present
            let restoredData = data;
            if (data.offer && data.offer._v) {
              restoredData = {
                ...data,
                offer: this.restoreSdp(data.offer),
              };
            } else if (data._v) {
              // Handle direct session description
              restoredData = this.restoreSdp(data);
            }

            this.log('Using compressed format');
            return restoredData;
          } catch (error) {
            this.log(`Both decompression methods failed: ${error.message}`);
            throw new Error('Invalid data format');
          }
        }

        optimizeSdp(sessionDescription) {
          const aliases = {
            // Extension mappings - most verbose
            'urn:ietf:params:rtp-hdrext:ssrc-audio-level': '@1',
            'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time': '@2',
            'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01':
              '@3',
            'urn:ietf:params:rtp-hdrext:sdes:mid': '@4',
            'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id': '@5',
            'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id': '@6',
            'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay': '@7',
            'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type':
              '@8',
            'http://www.webrtc.org/experiments/rtp-hdrext/video-timing': '@9',
            'http://www.webrtc.org/experiments/rtp-hdrext/color-space': '@10',

            // Common attributes
            'a=rtcp-mux': '@rtcp-mux',
            'a=rtcp-rsize': '@rtcp-rsize',
            'a=extmap-allow-mixed': '@extmap-mixed',
            'a=setup:actpass': '@setup',
            'a=mid:': '@mid:',
            'a=ice-ufrag:': '@ufrag:',
            'a=ice-pwd:': '@pwd:',
            'a=ice-options:trickle': '@ice-trickle',
            'a=fingerprint:sha-256 ': '@fp:',
            'a=sendrecv': '@sendrecv',
            'a=msid-semantic: WMS': '@msid-sem',

            // Codec patterns
            'a=rtpmap:': '@rtp:',
            'a=fmtp:': '@fmt:',
            'a=rtcp-fb:': '@fb:',

            // ICE candidate patterns
            'a=candidate:': '@c:',
            ' typ host ': ' h ',
            ' typ srflx ': ' s ',
            ' typ relay ': ' r ',
            ' generation 0': ' g0',

            // Common codec names
            'opus/48000/2': 'op48',
            'VP8/90000': 'vp8',
            'VP9/90000': 'vp9',
            'H264/90000': 'h264',
            'red/90000': 'red90',
            'ulpfec/90000': 'fec90',
            'rtx/90000': 'rtx90',
          };

          let optimizedSdp = sessionDescription.sdp;

          // Apply aliases
          for (const [original, alias] of Object.entries(aliases)) {
            optimizedSdp = optimizedSdp.replaceAll(original, alias);
          }

          // Create optimized session description
          const optimized = {
            type: sessionDescription.type,
            sdp: optimizedSdp,
            _v: 1, // Version marker for decompression
          };

          this.log(
            `SDP optimization: ${sessionDescription.sdp.length} ‚Üí ${
              optimizedSdp.length
            } chars (${Math.round(
              (1 - optimizedSdp.length / sessionDescription.sdp.length) * 100
            )}% reduction)`
          );

          return optimized;
        }

        restoreSdp(optimizedDescription) {
          // Check if this is an optimized version
          if (!optimizedDescription._v) {
            return optimizedDescription; // Already unoptimized
          }

          const reverseAliases = {
            // Extension mappings
            '@1': 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
            '@2': 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
            '@3': 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
            '@4': 'urn:ietf:params:rtp-hdrext:sdes:mid',
            '@5': 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id',
            '@6': 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
            '@7': 'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay',
            '@8': 'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type',
            '@9': 'http://www.webrtc.org/experiments/rtp-hdrext/video-timing',
            '@10': 'http://www.webrtc.org/experiments/rtp-hdrext/color-space',

            // Common attributes
            '@rtcp-mux': 'a=rtcp-mux',
            '@rtcp-rsize': 'a=rtcp-rsize',
            '@extmap-mixed': 'a=extmap-allow-mixed',
            '@setup': 'a=setup:actpass',
            '@mid:': 'a=mid:',
            '@ufrag:': 'a=ice-ufrag:',
            '@pwd:': 'a=ice-pwd:',
            '@ice-trickle': 'a=ice-options:trickle',
            '@fp:': 'a=fingerprint:sha-256 ',
            '@sendrecv': 'a=sendrecv',
            '@msid-sem': 'a=msid-semantic: WMS',

            // Codec patterns
            '@rtp:': 'a=rtpmap:',
            '@fmt:': 'a=fmtp:',
            '@fb:': 'a=rtcp-fb:',

            // ICE candidate patterns
            '@c:': 'a=candidate:',
            ' h ': ' typ host ',
            ' s ': ' typ srflx ',
            ' r ': ' typ relay ',
            ' g0': ' generation 0',

            // Common codec names
            op48: 'opus/48000/2',
            vp8: 'VP8/90000',
            vp9: 'VP9/90000',
            h264: 'H264/90000',
            red90: 'red/90000',
            fec90: 'ulpfec/90000',
            rtx90: 'rtx/90000',
          };

          let restoredSdp = optimizedDescription.sdp;

          // Apply reverse aliases
          for (const [alias, original] of Object.entries(reverseAliases)) {
            restoredSdp = restoredSdp.replaceAll(alias, original);
          }

          // Return restored session description without version marker
          return {
            type: optimizedDescription.type,
            sdp: restoredSdp,
          };
        }

        async requestUserMedia() {
          // Primary constraints
          const primaryConstraints = {
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: 'user',
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
            },
          };

          // Fallback constraints
          const fallbackConstraints = {
            video: true,
            audio: true,
          };

          try {
            this.log('Requesting user media with primary constraints...');
            return await navigator.mediaDevices.getUserMedia(
              primaryConstraints
            );
          } catch (error) {
            this.log(
              `Primary constraints failed: ${error.name}. Trying fallback...`
            );
            try {
              return await navigator.mediaDevices.getUserMedia(
                fallbackConstraints
              );
            } catch (fallbackError) {
              this.log(
                `Fallback constraints also failed: ${fallbackError.name}`
              );
              throw fallbackError;
            }
          }
        }

        handleMediaError(error, context) {
          this.log(`Error ${context}: ${error.name} - ${error.message}`);

          let userMessage = 'Camera/microphone access failed';
          let instructions = '';

          // Handle specific error types
          switch (error.name) {
            case 'NotAllowedError':
              userMessage = 'Camera/microphone permission denied';
              instructions =
                'Please allow camera and microphone access in your browser settings and refresh the page.';
              break;

            case 'NotFoundError':
              userMessage = 'No camera or microphone found';
              instructions =
                'Please ensure a camera and microphone are connected to your device.';
              break;

            case 'NotReadableError':
              userMessage = 'Camera/microphone is busy';
              instructions =
                'Please close other applications using your camera/microphone and try again.';
              break;

            case 'OverconstrainedError':
              userMessage = 'Camera/microphone constraints not supported';
              instructions =
                'Your device may not support the required video/audio settings.';
              break;

            case 'SecurityError':
              userMessage = 'Security error accessing media';
              instructions = this.isHTTPS()
                ? 'Please check your browser permissions for this site.'
                : 'HTTPS is required for camera access. Please use https:// or localhost.';
              break;

            case 'getUserMedia not supported':
              userMessage = 'Browser not supported';
              instructions =
                'Please use a modern browser like Chrome, Firefox, Safari, or Edge.';
              break;

            default:
              userMessage = 'Media access error';
              instructions =
                'Please check your camera/microphone settings and try again.';
          }

          // Show detailed error in UI
          this.updateStatus(`${userMessage}`, 'error');

          // Show instructions if available
          if (instructions) {
            setTimeout(() => {
              this.showAlert(`${userMessage}\n\n${instructions}`);
            }, 500);
          }

          // For some errors, show retry button
          if (
            error.name === 'NotReadableError' ||
            error.name === 'NotAllowedError'
          ) {
            this.showRetryOption(context);
          }
        }

        async checkCompatibility() {
          // Check basic WebRTC support
          if (!window.RTCPeerConnection) {
            return {
              compatible: false,
              message:
                'WebRTC is not supported in this browser. Please use Chrome, Firefox, Safari, or Edge.',
            };
          }

          // Check MediaDevices API
          if (!navigator.mediaDevices) {
            return {
              compatible: false,
              message:
                'Media devices API not supported. Please update your browser.',
            };
          }

          // Check getUserMedia support
          if (!navigator.mediaDevices.getUserMedia) {
            return {
              compatible: false,
              message:
                'Camera/microphone access not supported in this browser.',
            };
          }

          // Check if we can enumerate devices (helpful for debugging)
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const hasVideo = devices.some(
              (device) => device.kind === 'videoinput'
            );
            const hasAudio = devices.some(
              (device) => device.kind === 'audioinput'
            );

            this.log(
              `Detected devices - Video: ${hasVideo}, Audio: ${hasAudio}`
            );

            if (!hasVideo && !hasAudio) {
              this.log('Warning: No media devices detected');
            }
          } catch (error) {
            this.log(`Device enumeration failed: ${error.message}`);
          }

          // Check permissions API if available
          try {
            if (navigator.permissions) {
              const cameraPermission = await navigator.permissions.query({
                name: 'camera',
              });
              const micPermission = await navigator.permissions.query({
                name: 'microphone',
              });

              this.log(`Camera permission: ${cameraPermission.state}`);
              this.log(`Microphone permission: ${micPermission.state}`);

              if (
                cameraPermission.state === 'denied' ||
                micPermission.state === 'denied'
              ) {
                this.log('Warning: Media permissions previously denied');
              }
            }
          } catch (error) {
            this.log(`Permission check failed: ${error.message}`);
          }

          return { compatible: true };
        }

        showHTTPSWarning() {
          const httpsWarning = document.getElementById('https-warning');
          if (httpsWarning) {
            httpsWarning.classList.remove('hidden');

            // Auto-hide after 10 seconds but keep in console
            setTimeout(() => {
              httpsWarning.classList.add('hidden');
            }, 10000);
          }

          // Also show in status initially
          this.updateStatus('HTTPS recommended for camera access', 'error');

          // Show helpful popup
          setTimeout(() => {
            this.showAlert(
              '‚ö†Ô∏è HTTPS Required\n\nFor security reasons, modern browsers require HTTPS to access camera and microphone.\n\nSolutions:\n‚Ä¢ Use localhost for development\n‚Ä¢ Deploy with HTTPS certificate\n‚Ä¢ Use ngrok or similar tunneling service'
            );
          }, 2000);
        }

        showRetryOption(context) {
          // Add a retry button to the UI
          const retryBtn = document.createElement('button');
          retryBtn.className = 'btn';
          retryBtn.textContent = 'Retry Camera Access';
          retryBtn.onclick = () => {
            retryBtn.remove();
            if (context === 'creating offer') {
              this.createOffer();
            } else if (context === 'handling offer') {
              // For responder, we need to get the URL data again
              this.getUrlData().then((urlData) => {
                if (urlData) {
                  this.handleOffer(urlData);
                }
              });
            }
          };

          // Insert the retry button after the status
          const statusEl = document.getElementById('status');
          if (statusEl && statusEl.parentNode) {
            statusEl.parentNode.insertBefore(retryBtn, statusEl.nextSibling);
          }
        }

        isHTTPS() {
          return (
            window.location.protocol === 'https:' ||
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1'
          );
        }

        logSystemInfo() {
          this.log('=== System Information ===');
          this.log(`URL: ${window.location.href}`);
          this.log(`Protocol: ${window.location.protocol}`);
          this.log(`User Agent: ${navigator.userAgent}`);
          this.log(`Screen: ${screen.width}x${screen.height}`);
          this.log(`Viewport: ${window.innerWidth}x${window.innerHeight}`);
          this.log(`Touch Support: ${'ontouchstart' in window ? 'Yes' : 'No'}`);
          this.log(
            `WebRTC Support: ${window.RTCPeerConnection ? 'Yes' : 'No'}`
          );
          this.log(
            `getUserMedia Support: ${
              navigator.mediaDevices?.getUserMedia ? 'Yes' : 'No'
            }`
          );
          this.log(`Permissions API: ${navigator.permissions ? 'Yes' : 'No'}`);
          this.log('==========================');
        }

        log(message) {
          console.log(message);
          const debugEl = document.getElementById('debug');
          if (debugEl) {
            const time = new Date().toLocaleTimeString();
            debugEl.innerHTML += `[${time}] ${message}<br>`;
            debugEl.scrollTop = debugEl.scrollHeight;
          }
        }
      }

      // Initialize when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        new MobileWebRTC();
      });

      // Prevent zoom on double tap
      let lastTouchEnd = 0;
      document.addEventListener(
        'touchend',
        function (event) {
          const now = new Date().getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        false
      );
    </script>
  </body>
</html>
