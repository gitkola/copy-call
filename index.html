<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Copy Call</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: monospace;
        background: #000;
        color: #fff;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        overscroll-behavior: none;
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
          env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      .container {
        min-height: 100vh;
        max-width: 414px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        border-left: 1px solid #333;
        border-right: 1px solid #333;
      }

      .header {
        padding: 15px;
        background: rgba(0, 0, 0, 0.8);
        text-align: center;
        border-bottom: 1px solid #333;
      }

      .header h1 {
        font-size: 20px;
        font-weight: 600;
      }

      .status {
        padding: 12px 15px;
        font-weight: 500;
        font-size: 14px;
        text-align: center;
      }

      .status.waiting {
        background: #ff9500;
      }

      .status.connected {
        background: #34c759;
      }

      .status.error {
        background: #ff3b30;
      }

      .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 15px;
        gap: 20px;
      }

      .link-section,
      .code-section {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 15px;
      }

      .link-input,
      .code-textarea {
        width: 100%;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #333;
        border-radius: 8px;
        color: #fff;
        font-family: monospace;
        font-size: 12px;
        padding: 12px;
        margin-bottom: 15px;
        resize: none;
      }

      .code-textarea {
        min-height: 120px;
        font-size: 11px;
      }

      .btn {
        background: #007aff;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 15px 25px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
        margin-bottom: 10px;
        transition: background 0.2s;
        -webkit-appearance: none;
        appearance: none;
        touch-action: manipulation;
      }

      .btn:active {
        background: #005bb5;
        transform: scale(0.98);
      }

      .btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      .btn.success {
        background: #34c759;
      }

      .btn.success:active {
        background: #2fb44a;
      }

      .code-display {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 10px;
        font-family: monospace;
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
        word-break: break-all;
        line-height: 1.3;
        max-height: 60px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        border: 1px solid #333;
      }

      .video-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 300px;
      }

      .video-grid {
        display: grid;
        gap: 10px;
        flex: 1;
      }

      .video-grid.portrait {
        grid-template-rows: 1fr 1fr;
      }

      .video-grid.landscape {
        grid-template-columns: 1fr 1fr;
      }

      .video-box {
        background: #000;
        border-radius: 12px;
        position: relative;
        overflow: hidden;
        min-height: 150px;
      }

      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
      }

      .video-label {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 6px 12px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: 500;
      }

      .video-controls {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }

      .control-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        cursor: pointer;
        transition: all 0.2s;
        -webkit-appearance: none;
        appearance: none;
        touch-action: manipulation;
      }

      .control-btn.mic {
        background: rgba(0, 0, 0, 0.7);
        color: white;
      }

      .control-btn.mic.muted {
        background: #ff3b30;
        color: white;
      }

      .control-btn.camera {
        background: rgba(0, 0, 0, 0.7);
        color: white;
      }

      .control-btn.camera.disabled {
        background: #ff3b30;
        color: white;
      }

      .control-btn:active {
        transform: scale(0.9);
      }

      .video-box.local {
        position: relative;
      }

      .video-box.muted video {
        opacity: 0.7;
      }

      .video-box.camera-off video {
        opacity: 0.3;
      }

      .video-box.camera-off::after {
        content: 'ðŸ“·';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 40px;
        opacity: 0.8;
      }

      .placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        font-style: italic;
        text-align: center;
        padding: 20px;
      }

      .hidden {
        display: none !important;
      }

      .debug {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 10px;
        font-family: monospace;
        font-size: 10px;
        max-height: 100px;
        overflow-y: auto;
        margin-top: auto;
        -webkit-overflow-scrolling: touch;
      }

      .flex-col {
        display: flex;
        flex-direction: column;
      }

      .gap-20 {
        gap: 20px;
      }

      /* Landscape orientation adjustments */
      @media (orientation: landscape) and (max-height: 600px) {
        .header h1 {
          font-size: 16px;
        }

        .content {
          padding: 10px;
          gap: 15px;
        }

        .video-container {
          min-height: 200px;
        }

        .video-box {
          min-height: 120px;
        }
      }

      /* Remove desktop adaptations - keep mobile-only styling */
      @media (min-width: 415px) {
        .container {
          box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }
      }

      /* Prevent zoom on input focus */
      @media (max-width: 767px) {
        .link-input,
        .code-textarea {
          font-size: 16px;
        }
      }

      /* iOS specific styles */
      @supports (-webkit-touch-callout: none) {
        .btn {
          -webkit-tap-highlight-color: transparent;
        }
      }

      /* Floating Action Button */
      .fab {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: #ff3b30;
        color: white;
        border: none;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: all 0.3s;
        z-index: 1000;
        -webkit-appearance: none;
        appearance: none;
        touch-action: manipulation;
      }

      .fab:hover {
        transform: scale(1.1);
      }

      .fab:active {
        transform: scale(0.9);
      }

      @media (max-width: 414px) {
        .fab {
          right: 15px;
          bottom: 15px;
        }
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="header">
        <h1>Copy Call</h1>
      </div>

      <div id="status" class="status waiting">Initializing...</div>

      <div class="content">
        <!-- Initiator Mode: Generate Offer -->
        <div id="initiator-generate" class="hidden gap-20 flex-col">
          <div class="link-section">
            <input type="text" id="offer-link" class="link-input" readonly />
            <button id="copy-offer" class="btn">Copy Link</button>
          </div>

          <div class="code-section">
            <textarea
              id="answer-code-input"
              class="code-textarea"
              placeholder="Paste response code..."
            ></textarea>
            <button id="connect-btn" class="btn success">Connect</button>
          </div>
        </div>

        <!-- Responder Mode: Generate Code -->
        <div id="responder-generate" class="hidden">
          <div class="code-section">
            <div class="code-display" id="answer-code-display"></div>
            <button id="copy-code" class="btn">Copy Code</button>
          </div>

          <div class="video-container">
            <div class="video-grid portrait" id="responder-video-grid">
              <div class="video-box local" id="responder-local-box">
                <video
                  id="responder-local-video"
                  autoplay
                  muted
                  playsinline
                ></video>
                <div class="video-label">You</div>
                <div class="video-controls">
                  <button
                    class="control-btn mic"
                    id="responder-mic-btn"
                    title="Toggle microphone"
                  >
                    ðŸŽ¤
                  </button>
                  <button
                    class="control-btn camera"
                    id="responder-camera-btn"
                    title="Toggle camera"
                  >
                    ðŸ“¹
                  </button>
                </div>
              </div>
              <div class="video-box">
                <div class="placeholder" id="responder-remote-placeholder">
                  Waiting for connection...
                </div>
                <video
                  id="responder-remote-video"
                  autoplay
                  playsinline
                  class="hidden"
                ></video>
                <div class="video-label">Remote</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Connected Mode -->
        <div id="connected-mode" class="hidden">
          <div class="video-container">
            <div class="video-grid" id="connected-video-grid">
              <div class="video-box local" id="connected-local-box">
                <video id="local-video" autoplay muted playsinline></video>
                <div class="video-label">You</div>
                <div class="video-controls">
                  <button
                    class="control-btn mic"
                    id="connected-mic-btn"
                    title="Toggle microphone"
                  >
                    ðŸŽ¤
                  </button>
                  <button
                    class="control-btn camera"
                    id="connected-camera-btn"
                    title="Toggle camera"
                  >
                    ðŸ“¹
                  </button>
                </div>
              </div>
              <div class="video-box">
                <video id="remote-video" autoplay playsinline></video>
                <div class="video-label">Remote</div>
              </div>
            </div>
          </div>
        </div>

        <div id="debug" class="debug hidden"></div>
      </div>

      <!-- Floating Action Button -->
      <button id="reload-fab" class="fab hidden" title="Reload page">ðŸ”„</button>
    </div>

    <script>
      class MobileWebRTC {
        constructor() {
          this.pc = null;
          this.localStream = null;
          this.mode = null;
          this.currentCode = null;
          this.isLandscape = window.innerWidth > window.innerHeight;
          this.audioTrack = null;
          this.videoTrack = null;
          this.isMicEnabled = true;
          this.isCameraEnabled = true;

          this.init();
          this.setupOrientationHandling();
        }

        async init() {
          this.log('Initializing mobile WebRTC...');

          const urlData = await this.getUrlData();

          if (urlData && urlData.type === 'offer') {
            this.mode = 'responder';
            await this.handleOffer(urlData);
          } else {
            this.mode = 'initiator';
            await this.createOffer();
          }

          this.setupEventListeners();
        }

        setupOrientationHandling() {
          const updateLayout = () => {
            this.isLandscape = window.innerWidth > window.innerHeight;
            const videoGrids = document.querySelectorAll('.video-grid');

            videoGrids.forEach((grid) => {
              grid.className = `video-grid ${
                this.isLandscape ? 'landscape' : 'portrait'
              }`;
            });

            this.log(
              `Orientation: ${this.isLandscape ? 'landscape' : 'portrait'}`
            );
          };

          window.addEventListener('orientationchange', () => {
            setTimeout(updateLayout, 100);
          });

          window.addEventListener('resize', updateLayout);
          updateLayout();
        }

        setupEventListeners() {
          document
            .getElementById('copy-offer')
            .addEventListener('click', () => {
              this.copyToClipboard(
                document.getElementById('offer-link').value,
                'copy-offer'
              );
            });

          document.getElementById('copy-code').addEventListener('click', () => {
            this.copyToClipboard(this.currentCode, 'copy-code');
          });

          document
            .getElementById('connect-btn')
            .addEventListener('click', () => {
              this.handleAnswerCode();
            });

          // Prevent zoom on iOS when focusing textarea
          document
            .getElementById('answer-code-input')
            .addEventListener('touchstart', (e) => {
              e.target.style.fontSize = '16px';
            });

          // Setup media control buttons
          this.setupMediaControls();

          // Setup FAB
          this.setupFAB();
        }

        setupMediaControls() {
          // Responder mode controls
          const responderMicBtn = document.getElementById('responder-mic-btn');
          const responderCameraBtn = document.getElementById(
            'responder-camera-btn'
          );

          // Connected mode controls
          const connectedMicBtn = document.getElementById('connected-mic-btn');
          const connectedCameraBtn = document.getElementById(
            'connected-camera-btn'
          );

          if (responderMicBtn) {
            responderMicBtn.addEventListener('click', () =>
              this.toggleMicrophone()
            );
          }
          if (responderCameraBtn) {
            responderCameraBtn.addEventListener('click', () =>
              this.toggleCamera()
            );
          }
          if (connectedMicBtn) {
            connectedMicBtn.addEventListener('click', () =>
              this.toggleMicrophone()
            );
          }
          if (connectedCameraBtn) {
            connectedCameraBtn.addEventListener('click', () =>
              this.toggleCamera()
            );
          }
        }

        toggleMicrophone() {
          if (!this.audioTrack) return;

          this.isMicEnabled = !this.isMicEnabled;
          this.audioTrack.enabled = this.isMicEnabled;

          const micBtns = document.querySelectorAll('.control-btn.mic');
          const localBoxes = document.querySelectorAll('.video-box.local');

          micBtns.forEach((btn) => {
            if (this.isMicEnabled) {
              btn.classList.remove('muted');
              btn.textContent = 'ðŸŽ¤';
            } else {
              btn.classList.add('muted');
              btn.textContent = 'ðŸŽ¤';
            }
          });

          localBoxes.forEach((box) => {
            if (this.isMicEnabled) {
              box.classList.remove('muted');
            } else {
              box.classList.add('muted');
            }
          });

          this.log(`Microphone ${this.isMicEnabled ? 'enabled' : 'disabled'}`);
        }

        toggleCamera() {
          if (!this.videoTrack) return;

          this.isCameraEnabled = !this.isCameraEnabled;
          this.videoTrack.enabled = this.isCameraEnabled;

          const cameraBtns = document.querySelectorAll('.control-btn.camera');
          const localBoxes = document.querySelectorAll('.video-box.local');

          cameraBtns.forEach((btn) => {
            if (this.isCameraEnabled) {
              btn.classList.remove('disabled');
              btn.textContent = 'ðŸ“¹';
            } else {
              btn.classList.add('disabled');
              btn.textContent = 'ðŸ“¹';
            }
          });

          localBoxes.forEach((box) => {
            if (this.isCameraEnabled) {
              box.classList.remove('camera-off');
            } else {
              box.classList.add('camera-off');
            }
          });

          this.log(`Camera ${this.isCameraEnabled ? 'enabled' : 'disabled'}`);
        }

        setupFAB() {
          const reloadFab = document.getElementById('reload-fab');
          if (reloadFab) {
            reloadFab.addEventListener('click', () => {
              window.location.reload();
            });
          }
        }

        showFAB() {
          const reloadFab = document.getElementById('reload-fab');
          if (reloadFab) {
            reloadFab.classList.remove('hidden');
          }
        }

        hideResponderInterface() {
          // Hide the code section but keep video
          const codeSection = document.querySelector(
            '#responder-generate .code-section'
          );
          if (codeSection) {
            codeSection.classList.add('hidden');
          }
          this.log('Responder interface hidden - showing only video');
        }

        setupPeerConnection() {
          this.pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
            ],
          });

          this.pc.oniceconnectionstatechange = () => {
            this.log(`ICE: ${this.pc.iceConnectionState}`);
          };

          this.pc.onconnectionstatechange = () => {
            this.log(`Connection: ${this.pc.connectionState}`);
            if (this.pc.connectionState === 'connected') {
              this.updateStatus('Connected! Video call active.', 'connected');
              this.showFAB();

              if (this.mode === 'initiator') {
                this.showConnectedMode();
              } else if (this.mode === 'responder') {
                // Hide responder interface, keep only video
                this.hideResponderInterface();
              }
            }
          };

          this.pc.ontrack = (event) => {
            this.log(`Remote track received: ${event.track.kind}`);
            const stream = event.streams[0];
            this.displayRemoteVideo(stream);
          };

          this.log('PeerConnection setup complete');
        }

        async createOffer() {
          this.log('Creating offer...');
          this.showMode('initiator-generate');
          this.updateStatus('Generating offer link...');

          this.setupPeerConnection();

          try {
            // Get user media with mobile-optimized constraints
            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user',
              },
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
              },
            });

            // Store track references and add tracks
            this.localStream.getTracks().forEach((track) => {
              this.pc.addTrack(track, this.localStream);
              this.log(`Added ${track.kind} track`);

              if (track.kind === 'audio') {
                this.audioTrack = track;
              } else if (track.kind === 'video') {
                this.videoTrack = track;
              }
            });

            // Create offer
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            // Wait for ICE
            await this.waitForIceGathering();

            // Generate offer link
            const linkData = {
              type: 'offer',
              offer: this.pc.localDescription,
            };

            const link = await this.generateLink(linkData);
            document.getElementById('offer-link').value = link;

            this.updateStatus('Share the link and wait for response code');
          } catch (error) {
            this.log(`Error creating offer: ${error.message}`);
            this.updateStatus('Error accessing camera/microphone', 'error');
          }
        }

        async handleOffer(urlData) {
          this.log('Handling incoming offer...');
          this.showMode('responder-generate');
          this.updateStatus('Processing offer...');

          this.setupPeerConnection();

          try {
            // Get user media with mobile constraints
            this.localStream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user',
              },
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
              },
            });

            // Display local video
            document.getElementById('responder-local-video').srcObject =
              this.localStream;

            // Store track references and add tracks
            this.localStream.getTracks().forEach((track) => {
              this.pc.addTrack(track, this.localStream);
              this.log(`Added ${track.kind} track`);

              if (track.kind === 'audio') {
                this.audioTrack = track;
              } else if (track.kind === 'video') {
                this.videoTrack = track;
              }
            });

            // Process offer
            await this.pc.setRemoteDescription(urlData.offer);

            // Create answer
            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);

            // Wait for ICE
            await this.waitForIceGathering();

            // Generate compressed answer
            const encodedAnswer = await this.compressData(
              this.pc.localDescription
            );
            this.currentCode = encodedAnswer;

            document.getElementById('answer-code-display').textContent =
              encodedAnswer;

            this.updateStatus('Code generated! Send it back to connect.');
          } catch (error) {
            this.log(`Error handling offer: ${error.message}`);
            this.updateStatus('Error accessing camera/microphone', 'error');
          }
        }

        async handleAnswerCode() {
          const codeInput = document.getElementById('answer-code-input');
          const encodedData = codeInput.value.trim();

          if (!encodedData) {
            this.showAlert('Please paste the response code');
            return;
          }

          this.log('Processing response code...');

          try {
            const answer = await this.decompressData(encodedData);
            await this.pc.setRemoteDescription(answer);
            this.log('Response code applied successfully');
            this.updateStatus('Connecting...');

            // Show video interface
            this.showConnectedMode();
          } catch (error) {
            this.log(`Error with response code: ${error.message}`);
            this.showAlert(
              'Invalid response code. Please check and try again.'
            );
          }
        }

        displayRemoteVideo(stream) {
          this.log(`Displaying remote video for mode: ${this.mode}`);

          if (this.mode === 'responder') {
            const placeholder = document.getElementById(
              'responder-remote-placeholder'
            );
            const video = document.getElementById('responder-remote-video');

            if (placeholder) placeholder.classList.add('hidden');
            if (video) {
              video.srcObject = stream;
              video.classList.remove('hidden');
              this.log('Responder remote video set');
            }
          } else {
            const video = document.getElementById('remote-video');
            if (video) {
              video.srcObject = stream;
              this.log('Initiator remote video set');
            }
          }
        }

        showConnectedMode() {
          this.showMode('connected-mode');

          if (this.localStream) {
            document.getElementById('local-video').srcObject = this.localStream;
          }

          if (this.pc.connectionState !== 'connected') {
            this.updateStatus('Connecting...');
          }
        }

        waitForIceGathering() {
          return new Promise((resolve) => {
            if (this.pc.iceGatheringState === 'complete') {
              resolve();
              return;
            }

            const timeout = setTimeout(() => {
              this.log('ICE gathering timeout');
              resolve();
            }, 3000);

            this.pc.addEventListener('icegatheringstatechange', () => {
              if (this.pc.iceGatheringState === 'complete') {
                clearTimeout(timeout);
                resolve();
              }
            });
          });
        }

        async generateLink(data) {
          const encoded = await this.compressData(data);
          const baseUrl = window.location.href.split('#')[0];
          return `${baseUrl}#${encoded}`;
        }

        async getUrlData() {
          const hash = window.location.hash.substring(1);
          if (!hash) return null;

          try {
            return await this.decompressData(hash);
          } catch (error) {
            this.log(`Error parsing URL: ${error.message}`);
            return null;
          }
        }

        showMode(mode) {
          document
            .querySelectorAll(
              '#initiator-generate, #responder-generate, #connected-mode'
            )
            .forEach((el) => {
              el.classList.add('hidden');
            });
          document.getElementById(mode).classList.remove('hidden');
        }

        updateStatus(message, type = 'waiting') {
          const statusEl = document.getElementById('status');
          statusEl.textContent = message;
          statusEl.className = `status ${type}`;
        }

        showAlert(message) {
          // Use native alert for now, could be replaced with custom modal
          alert(message);
        }

        async copyToClipboard(text, buttonId) {
          try {
            await navigator.clipboard.writeText(text);
            const button = document.getElementById(buttonId);
            const originalText = button.textContent;
            button.textContent = 'âœ“ Copied!';
            button.disabled = true;

            setTimeout(() => {
              button.textContent = originalText;
              button.disabled = false;
            }, 2000);
          } catch (error) {
            this.log(`Copy failed: ${error.message}`);
            this.showAlert('Copy failed. Please copy manually.');
          }
        }

        async compressData(data) {
          try {
            // Optimize SDP before compression if it contains an offer/answer
            let optimizedData = data;
            if (data.offer && data.offer.sdp) {
              optimizedData = {
                ...data,
                offer: this.optimizeSdp(data.offer),
              };
            } else if (data.sdp) {
              // Handle direct session description
              optimizedData = this.optimizeSdp(data);
            }

            const jsonString = JSON.stringify(optimizedData);
            const stream = new CompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();

            const encoder = new TextEncoder();
            const chunks = [];

            writer.write(encoder.encode(jsonString));
            writer.close();

            let done = false;
            while (!done) {
              const { value, done: readerDone } = await reader.read();
              done = readerDone;
              if (value) {
                chunks.push(value);
              }
            }

            const compressed = new Uint8Array(
              chunks.reduce((acc, chunk) => acc + chunk.length, 0)
            );
            let offset = 0;
            for (const chunk of chunks) {
              compressed.set(chunk, offset);
              offset += chunk.length;
            }

            const base64 = btoa(String.fromCharCode(...compressed));
            this.log(
              `Compression: ${jsonString.length} â†’ ${
                base64.length
              } chars (${Math.round(
                (1 - base64.length / jsonString.length) * 100
              )}% reduction)`
            );
            return base64;
          } catch (error) {
            this.log(
              `Compression failed: ${error.message}, falling back to uncompressed`
            );
            return btoa(JSON.stringify(data));
          }
        }

        async decompressData(compressedBase64) {
          try {
            const compressed = new Uint8Array(
              atob(compressedBase64)
                .split('')
                .map((c) => c.charCodeAt(0))
            );
            const stream = new DecompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();

            const chunks = [];

            writer.write(compressed);
            writer.close();

            let done = false;
            while (!done) {
              const { value, done: readerDone } = await reader.read();
              done = readerDone;
              if (value) {
                chunks.push(value);
              }
            }

            const decompressed = new Uint8Array(
              chunks.reduce((acc, chunk) => acc + chunk.length, 0)
            );
            let offset = 0;
            for (const chunk of chunks) {
              decompressed.set(chunk, offset);
              offset += chunk.length;
            }

            const decoder = new TextDecoder();
            const jsonString = decoder.decode(decompressed);
            const data = JSON.parse(jsonString);

            // Restore SDP optimization if present
            let restoredData = data;
            if (data.offer && data.offer._v) {
              restoredData = {
                ...data,
                offer: this.restoreSdp(data.offer),
              };
            } else if (data._v) {
              // Handle direct session description
              restoredData = this.restoreSdp(data);
            }

            return restoredData;
          } catch (error) {
            this.log(
              `Decompression failed: ${error.message}, trying uncompressed format`
            );
            return JSON.parse(atob(compressedBase64));
          }
        }

        optimizeSdp(sessionDescription) {
          const aliases = {
            // Extension mappings - most verbose
            'urn:ietf:params:rtp-hdrext:ssrc-audio-level': '@1',
            'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time': '@2',
            'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01':
              '@3',
            'urn:ietf:params:rtp-hdrext:sdes:mid': '@4',
            'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id': '@5',
            'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id': '@6',
            'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay': '@7',
            'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type':
              '@8',
            'http://www.webrtc.org/experiments/rtp-hdrext/video-timing': '@9',
            'http://www.webrtc.org/experiments/rtp-hdrext/color-space': '@10',

            // Common attributes
            'a=rtcp-mux': '@rtcp-mux',
            'a=rtcp-rsize': '@rtcp-rsize',
            'a=extmap-allow-mixed': '@extmap-mixed',
            'a=setup:actpass': '@setup',
            'a=mid:': '@mid:',
            'a=ice-ufrag:': '@ufrag:',
            'a=ice-pwd:': '@pwd:',
            'a=ice-options:trickle': '@ice-trickle',
            'a=fingerprint:sha-256 ': '@fp:',
            'a=sendrecv': '@sendrecv',
            'a=msid-semantic: WMS': '@msid-sem',

            // Codec patterns
            'a=rtpmap:': '@rtp:',
            'a=fmtp:': '@fmt:',
            'a=rtcp-fb:': '@fb:',

            // ICE candidate patterns
            'a=candidate:': '@c:',
            ' typ host ': ' h ',
            ' typ srflx ': ' s ',
            ' typ relay ': ' r ',
            ' generation 0': ' g0',
            ' network-id ': ' n',
            ' network-cost ': ' nc',

            // Common codec names
            'opus/48000/2': 'op48',
            'VP8/90000': 'vp8',
            'VP9/90000': 'vp9',
            'H264/90000': 'h264',
            'red/90000': 'red90',
            'ulpfec/90000': 'fec90',
            'rtx/90000': 'rtx90',
          };

          let optimizedSdp = sessionDescription.sdp;

          // Apply aliases
          for (const [original, alias] of Object.entries(aliases)) {
            optimizedSdp = optimizedSdp.replaceAll(original, alias);
          }

          // Create optimized session description
          const optimized = {
            type: sessionDescription.type,
            sdp: optimizedSdp,
            _v: 1, // Version marker for decompression
          };

          this.log(
            `SDP optimization: ${sessionDescription.sdp.length} â†’ ${
              optimizedSdp.length
            } chars (${Math.round(
              (1 - optimizedSdp.length / sessionDescription.sdp.length) * 100
            )}% reduction)`
          );

          return optimized;
        }

        restoreSdp(optimizedDescription) {
          // Check if this is an optimized version
          if (!optimizedDescription._v) {
            return optimizedDescription; // Already unoptimized
          }

          const reverseAliases = {
            // Extension mappings
            '@1': 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
            '@2': 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
            '@3': 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
            '@4': 'urn:ietf:params:rtp-hdrext:sdes:mid',
            '@5': 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id',
            '@6': 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
            '@7': 'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay',
            '@8': 'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type',
            '@9': 'http://www.webrtc.org/experiments/rtp-hdrext/video-timing',
            '@10': 'http://www.webrtc.org/experiments/rtp-hdrext/color-space',

            // Common attributes
            '@rtcp-mux': 'a=rtcp-mux',
            '@rtcp-rsize': 'a=rtcp-rsize',
            '@extmap-mixed': 'a=extmap-allow-mixed',
            '@setup': 'a=setup:actpass',
            '@mid:': 'a=mid:',
            '@ufrag:': 'a=ice-ufrag:',
            '@pwd:': 'a=ice-pwd:',
            '@ice-trickle': 'a=ice-options:trickle',
            '@fp:': 'a=fingerprint:sha-256 ',
            '@sendrecv': 'a=sendrecv',
            '@msid-sem': 'a=msid-semantic: WMS',

            // Codec patterns
            '@rtp:': 'a=rtpmap:',
            '@fmt:': 'a=fmtp:',
            '@fb:': 'a=rtcp-fb:',

            // ICE candidate patterns
            '@c:': 'a=candidate:',
            ' h ': ' typ host ',
            ' s ': ' typ srflx ',
            ' r ': ' typ relay ',
            ' g0': ' generation 0',
            ' n': ' network-id ',
            ' nc': ' network-cost ',

            // Common codec names
            op48: 'opus/48000/2',
            vp8: 'VP8/90000',
            vp9: 'VP9/90000',
            h264: 'H264/90000',
            red90: 'red/90000',
            fec90: 'ulpfec/90000',
            rtx90: 'rtx/90000',
          };

          let restoredSdp = optimizedDescription.sdp;

          // Apply reverse aliases
          for (const [alias, original] of Object.entries(reverseAliases)) {
            restoredSdp = restoredSdp.replaceAll(alias, original);
          }

          // Return restored session description without version marker
          return {
            type: optimizedDescription.type,
            sdp: restoredSdp,
          };
        }

        log(message) {
          console.log(message);
          const debugEl = document.getElementById('debug');
          const time = new Date().toLocaleTimeString();
          debugEl.innerHTML += `[${time}] ${message}<br>`;
          debugEl.scrollTop = debugEl.scrollHeight;
        }
      }

      // Initialize when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        new MobileWebRTC();
      });

      // Prevent zoom on double tap
      let lastTouchEnd = 0;
      document.addEventListener(
        'touchend',
        function (event) {
          const now = new Date().getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        false
      );
    </script>
  </body>
</html>
